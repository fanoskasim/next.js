---
title: How caching works in Next.js
nav_title: Caching
description: An deep dive into how caching works in Next.js
---

Caching is a technique for storing the result of expensive work (rendering, data fetching, and other computations) so that future requests for the same content can be served faster, without recomputing the result.

In this deep dive, you’ll learn:

- [How caching works in Next.js](#how-caching-works-in-nextjs)
- [How to define cache boundaries with `"use cache"`](#how-use-cache-works)
- How to define update semantics with `cacheLife` and `cacheTag`
- How to configure a remote, persistent cache (coming soon)

## How caching works in Next.js

In Next.js, caching can be described as:

- [Client-first](#client-first): The browser becomes an active participant in caching, and is the first place Next.js checks for cached data or UI.
- [Declarative](#declarative): You describe when a cache should be updated, rather than how and where the cache is stored.
- [Granular](#granular): You can cache components and individual async functions, rather than the entire page.

### Client-first

Historically, web frameworks were primarily concerned with **server-side** caching:

- Cache was coupled to infrastructure (e.g. [ISR](https://vercel.com/docs/incremental-static-regeneration), [Data Cache](https://vercel.com/docs/data-cache), CDNs, etc).
- Pages were described as entirely static or dynamic:
  - Static: Prerendered and cached on the server.
  - Dynamic: Re-rendered at request time.
- Personalized data bypassed caching altogether.

Next.js uses both the client and server environments for caching. When resolving a cache miss, it checks:

1. The client cache (prefetched or previously visited content)
2. The server in-memory cache (Lambda or Node runtime)
3. A persistent remote cache, if defined (e.g. [ISR](https://vercel.com/docs/incremental-static-regeneration) or [Data Cache](https://vercel.com/docs/data-cache))

{/* TODO: Add diagram */}

By making caching **client-first**, we can reduce unnecessary server requests and optimize React Server Components to provide a similar **user experience** as Single-Page Applications (SPAs)—while still leveraging the benefits of doing work on the server. For the user, it means faster navigation and less intermediary loading states like skeletons and spinners.

However, **client-first does not mean client-only**. The server still plays a role in:

- Executing logic when needed (e.g. data fetching and rendering)
- Deduping requests for the same content (in-memory caching)
- Reusing static shells across users (PPR)
- Persisting the result in a remote cache (e.g. ISR, CDN, etc)

In this hybrid model, the client is prioritized, becoming an active participant in improving the navigation experience and reducing server load.

### Declarative

Next.js caching APIs let you describe caching **semantics** instead of caching **mechanics**.

Instead of asking: _"Where should this be cached?"_
You ask: _"When should this cache be updated?"_

In other words:

- You describe the [update semantics](#update-semantics): how long something is fresh, when it should revalidate, and what causes invalidation.
- Next.js determines the most appropriate environment and layer based on your declared semantics.

This declarative and agnostic approach allows Next.js to provide a consistent API regardless of your static or dynamic requirements and infrastructure setup.

### Granular

Modern web applications are **dynamic**, **personalized**, **interactive**, and require a granular approach to caching, specifically for:

1. [**Dynamic route segments**](/docs/app/building-your-application/routing/dynamic-routes) - which can potentially create a large number of unique pages. Trying to prerender or cache all of them on the server can be time-consuming and server-intensive.
2. **Personalized content** - some content can only be fetched after authentication—once a browser session exists and cookies are available.

In Next.js, in addition to caching entire pages, you can more granularly cache:

- Route Segments (e.g. layouts, static shell)
- Nested UI components (e.g. user avatar and name)
- Individual data fetching functions (e.g. `getUser()`)

## Caching APIs

There are three main APIs used for caching:

- [`"use cache"`](#how-use-cache-works): Defines a cache **boundary** for an async Server Component or function.
- [`cacheLife()`](#how-cacheLife-works): Defines the cache lifetime for a component or function.
- [`cacheTag()`](#how-cacheTag-works): Defines a cache tag across multiple boundaries to be invalidated together.

## How `"use cache"` works

`"use cache"` is a Next.js directive you can place inside an async [Server Component](https://react.dev/reference/rsc/server-components) or function to declare a **cache boundary**. This tells Next.js to cache the **return value** of that function or component based on its inputs.

```tsx filename="app/lib/data.ts" switcher
export async function getUser(id: string) {
  'use cache'
  // Fetch data
}
```

```jsx filename="app/lib/data.js" switcher
export async function getUser(id) {
  'use cache'
  // Fetch data
}
```

Similar to React's [`"use server"`](https://react.dev/reference/rsc/use-server) directive, functions annotated with `"use cache"` are compiled into [Server Functions](https://react.dev/reference/rsc/server-functions).

Behind-the-scenes, Next.js:

1. Wraps the Server Function with a [Higher Order Component](https://legacy.reactjs.org/docs/higher-order-components.html) that integrates the necessary caching behaviors.
2. Generates an unique [cache key](#cache-keys) for the entry.
3. Deduplicates identical calls using React’s [`cache`](https://react.dev/reference/react/cache) function.
4. Annotates the Server Component Payload and sends it to the client with the necessary semantics for how it should treat the cached content.

On the client, the payload is reused during navigation—leading to faster page transitions.

### Cache keys

Each cache boundary creates an unique cache entry, which is generated from:

- The build ID (generated for each build)
- The function signature (a secure identifier unique to the function)
- Any [serializable](#serialization) arguments or props passed to the function

If the arguments or props passed to the function are different, a new cache entry is created. For example:

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

By default, the `<Link>` component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.

To disable prefetching, you can set the `prefetch` prop to `false`. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.

Learn more about the [`<Link>` component](/docs/app/api-reference/components/link).

### `router.prefetch`

The `prefetch` option of the `useRouter` hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.

See the [`useRouter` hook](/docs/app/api-reference/functions/use-router) API reference.

### `router.refresh`

The `refresh` option of the `useRouter` hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route. `refresh` does not affect the Data or Full Route Cache.

The rendered result will be reconciled on the client while preserving React state and browser state.

See the [`useRouter` hook](/docs/app/api-reference/functions/use-router) API reference.

### `fetch`

Data returned from `fetch` is _not_ automatically cached in the Data Cache.

The default caching behavior of `fetch` (e.g., when the `cache` option is not specified) is equal to setting the `cache` option to `no-store`:

```js
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch) for more options.

### `fetch options.cache`

You can opt individual `fetch` into caching by setting the `cache` option to `force-cache`:

```jsx
// Opt into caching
fetch(`https://...`, { cache: 'force-cache' })
```

See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch) for more options.

### `fetch options.next.revalidate`

You can use the `next.revalidate` option of `fetch` to set the revalidation period (in seconds) of an individual `fetch` request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.

```jsx
// Revalidate at most after 1 hour
fetch(`https://...`, { next: { revalidate: 3600 } })
```

See the [`fetch` API reference](/docs/app/api-reference/functions/fetch) for more options.

### `fetch options.next.tags` and `revalidateTag`

Next.js has a cache tagging system for fine-grained data caching and revalidation.

1. When using `fetch` or [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache), you have the option to tag cache entries with one or more tags.
2. Then, you can call `revalidateTag` to purge the cache entries associated with that tag.

For example, you can set a tag when fetching data:

```jsx
// Cache data with a tag
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

Then, call `revalidateTag` with a tag to purge the cache entry:

```jsx
// Revalidate entries with a specific tag
revalidateTag('a')
```

There are two places you can use `revalidateTag`, depending on what you're trying to achieve:

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - to revalidate data in response of a third party event (e.g. webhook). This will not invalidate the Router Cache immediately as the Router Handler isn't tied to a specific route.
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - to revalidate data after a user action (e.g. form submission). This will invalidate the Router Cache for the associated route.

### `revalidatePath`

`revalidatePath` allows you manually revalidate data **and** re-render the route segments below a specific path in a single operation. Calling the `revalidatePath` method revalidates the Data Cache, which in turn invalidates the Full Route Cache.

```jsx
revalidatePath('/')
```

There are two places you can use `revalidatePath`, depending on what you're trying to achieve:

1. [Route Handlers](/docs/app/building-your-application/routing/route-handlers) - to revalidate data in response to a third party event (e.g. webhook).
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations) - to revalidate data after a user interaction (e.g. form submission, clicking a button).

See the [`revalidatePath` API reference](/docs/app/api-reference/functions/revalidatePath) for more information.

> **`revalidatePath`** vs. **`router.refresh`**:
>
> Calling `router.refresh` will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache.
>
> The difference is that `revalidatePath` purges the Data Cache and Full Route Cache, whereas `router.refresh()` does not change the Data Cache and Full Route Cache, as it is a client-side API.

### Dynamic APIs

Dynamic APIs like `cookies` and `headers`, and the `searchParams` prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.

#### `cookies`

Using `cookies.set` or `cookies.delete` in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes).

See the [`cookies`](/docs/app/api-reference/functions/cookies) API reference.

### Segment Config Options

The Route Segment Config options can be used to override the route segment defaults or when you're not able to use the `fetch` API (e.g. database client or 3rd party libraries).

The following Route Segment Config options will opt out of the Full Route Cache:

- `const dynamic = 'force-dynamic'`

This config option will opt all fetches out of the Data Cache (i.e. `no-store`):

- `const fetchCache = 'default-no-store'`

See the [`fetchCache`](/docs/app/api-reference/file-conventions/route-segment-config#fetchcache) to see more advanced options.

See the [Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config) documentation for more options.

### `generateStaticParams`

For [dynamic segments](/docs/app/building-your-application/routing/dynamic-routes) (e.g. `app/blog/[slug]/page.js`), paths provided by `generateStaticParams` are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited.

To statically render all paths at build time, supply the full list of paths to `generateStaticParams`:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())

  // Render the first 10 posts at build time
  return posts.slice(0, 10).map((post) => ({
    slug: post.slug,
  }))
}
```

To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize [`export const dynamic = 'force-static'`](/docs/app/api-reference/file-conventions/route-segment-config#dynamic):

```jsx filename="app/blog/[slug]/page.js"
export async function generateStaticParams() {
  return []
}
```

> **Good to know:** You must return an array from `generateStaticParams`, even if it's empty. Otherwise, the route will be dynamically rendered.

```jsx filename="app/changelog/[slug]/page.js"
export const dynamic = 'force-static'
```

To disable caching at request time, add the `export const dynamicParams = false` option in a route segment. When this config option is used, only paths provided by `generateStaticParams` will be served, and other routes will 404 or match (in the case of [catch-all routes](/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)).

### React `cache` function

The React `cache` function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.

Since `fetch` requests are automatically memoized, you do not need to wrap it in React `cache`. However, you can use `cache` to manually memoize data requests for use cases when the `fetch` API is not suitable. For example, some database clients, CMS clients, or GraphQL clients.

```ts filename="utils/get-item.ts" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

```js filename="utils/get-item.js" switcher
import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```
