---
title: How to cache and revalidate components and functions
nav_title: Caching and Revalidating
description: Learn how to cache and revalidate components and functions in your Next.js application.
related:
  title: API Reference
  description: Learn more about the features mentioned in this page by reading the API Reference.
  links:
    - app/api-reference/directives/use-cache
    - app/api-reference/functions/cacheLife
    - app/api-reference/functions/cacheTag
    - app/api-reference/functions/revalidateTag
    - app/api-reference/functions/revalidatePath
---

Next.js uses the server and client environments for caching.

- On the server, you can cache the output of components and functions to reduce the need to recompute work for every user request.
- On the client, the cached content from the server is temporarily stored in the browser to reduce the number of server requests on navigation.

This page describes how you can cache and revalidate routes, components, and functions.

## Server-side caching

### Static routes (default)

By default, routes are **prerendered** at build time. The result is cached and shared between users and server requests.

Prerendering is useful when a route has data that is not personalized to the user and can be known ahead of time, such as a static blog post or a product page.

### Dynamic routes

Using a [Dynamic API](#dynamic-apis) or a [fetch](/docs/app/api-reference/functions/fetch) request with the `{ cache: 'no-store' }` option will make a route dynamic, meaning it'll be rendered at runtime and the result won't be cached between user requests.

Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time.

> During development, you can check if a route is static or dynamic by running `next dev` and opening the [Next.js Dev Tools](/docs/app/api-reference/config/next-config-js/devIndicators) in your local host.

#### Dynamic APIs

Dynamic APIs rely on information that can only be known at request time. These APIs are:

- [`cookies`](/docs/app/api-reference/functions/cookies)
- [`headers`](/docs/app/api-reference/functions/headers)
- [`connection`](/docs/app/api-reference/functions/connection)
- [`draftMode`](/docs/app/api-reference/functions/draft-mode)
- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)
- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)

### Optimizing with streaming

To optimize the initial loading performance of dynamic routes, you can use React's [`<Suspense>` boundary](https://react.dev/reference/react/Suspense) or [`loading.js`](/docs/app/api-reference/file-conventions/loading) to show loading UI and progressively **stream** dynamic content to the client.

With streaming, the route is split into _chunks_ and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before all the fetching and rendering work is complete.

For example, the `<User>` component uses the `cookies` API to fetch the current user's information. Using it anywhere in a route will make the route dynamic and block it from being sent to the client until the data is fetched.

```tsx filename="app/ui/user.tsx" switcher
import { cookies } from 'next/headers'

export async function User() {
  const store = await cookies()
  const { id } = store.get('user')
  const user = await fetch(`https://api.vercel.app/users/${id}`)
  return <>...</>
}
```

```jsx filename="app/ui/user.js" switcher
import { cookies } from 'next/headers'

export async function User() {
  const store = await cookies()
  const { id } = store.get('user')
  const user = await fetch(`https://api.vercel.app/users/${id}`)
  return <>...</>
}
```

To prevent the whole route from being blocked, you can wrap the component in a `Suspense` boundary. This means the `<Navigation>` component and a fallback will be sent to the client first, while the nested `<User>` component, which relies on a potentially blocking request, will be streamed when it's ready.

```tsx filename="app/ui/navigation.tsx" switcher
import { Suspense } from 'react'
import { Link } from 'next/link'
import { User } from '@/app/ui/user'

export default function Navigation() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Suspense fallback={<div>Loading...</div>}>
        <User />
      </Suspense>
    </nav>
  )
}
```

```jsx filename="app/ui/navigation.js" switcher
import { Suspense } from 'react'
import { Link } from 'next/link'
import { User } from '@/app/ui/user'

export default function Navigation() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Suspense fallback={<div>Loading...</div>}>
        <User />
      </Suspense>
    </nav>
  )
}
```

```tsx filename="app/layout.tsx" switcher
import { Navigation } from '@/app/ui/navigation'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <Navigation />
        <main>{children}</main>
      </body>
    </html>
  )
}
```

```jsx filename="app/blog/layout.js" switcher
import { Navigation } from '@/app/ui/navigation'

export default function DashboardLayout({ children }) {
  return (
    <html>
      <body>
        <Navigation />
        <main>{children}</main>
      </body>
    </html>
  )
}
```

### Optimizing with `"use cache"`

> **Warning:** This section assumes the [`useCache` config option](/docs/app/api-reference/config/next-config-js/useCache) is enabled in your application. This option was introduced in Next.js 15 canary.

In addition to streaming, you can optimize dynamic routes by caching the output of nested components or functions.

Following the example above, the blog list page is now dynamic because `cookies` is nested in the parent blog layout. However, the blog list doesn't need to update on every request. To ensure this page is cached, make the component **asynchronous**, and add the [`'use cache'`](/docs/app/api-reference/directives/use-cache) directive:

```tsx filename="app/blog/page.tsx" highlight={6}switcher
import { BlogPost } from '@/app/ui/BlogPost'
import { CommentSection } from '@/app/ui/CommentSection'
import { getPosts } from '@/app/lib/data'

export default async function BlogListPage() {
  'use cache'
  const posts = await getPosts()

  return (
    <div>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </div>
  )
}
```

```jsx filename="app/blog/page.js" highlight={6} switcher
import { BlogPost } from '@/app/ui/BlogPost'
import { CommentSection } from '@/app/ui/CommentSection'
import { getPosts } from '@/app/lib/data'

export default async function BlogListPage() {
  'use cache'
  const posts = await getPosts()

  return (
    <div>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </div>
  )
}
```

In the example above, the component is being cached. But you can also cache a function's return value:

```tsx filename="app/lib/data.ts" highlight={2} switcher
export async function getPosts() {
  'use cache'
  const data = await fetch(`https://api.vercel.app/posts`)
  return data.json()
}
```

```jsx filename="app/lib/data.js" highlight={2} switcher
export async function getPosts() {
  'use cache'
  const data = await fetch(`https://api.vercel.app/posts`)
  return data.json()
}
```

With the above approach, whenever the `getPosts` function is called in your application, the same cached value will be reused as long as the arguments passed to the function are the same. Learn more about `use cache` in the [API Reference](/docs/app/api-reference/directives/use-cache).

### Components

You can add `'use cache'` to an **asynchronous** [Server Component](https://react.dev/reference/rsc/server-components) to cache the component's render output:

```tsx filename="app/blog/page.tsx" highlight={4} switcher
import { getPosts } from '@/app/lib/data'

export default async function Page() {
  'use cache'
  const posts = await getPosts()

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

```js filename="app/blog/page.js" highlight={4} switcher
import { getPosts } from '@/app/lib/data'

export default async function Page() {
  'use cache'
  const posts = await getPosts()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

Alternatively, you can add the `'use cache'` directive at the top of the file to mark all components in the file as cacheable. Each component will be cached separately, with its own cache key.

```tsx filename="app/blog/page.tsx" highlight={1} switcher
'use cache'

import { getPosts } from '@/app/lib/data'

export default async function Page() {
  const posts = await getPosts()

  return <Posts posts={posts} />
}

async function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

```js filename="app/blog/page.js" highlight={1} switcher
'use cache'

import { getPosts } from '@/app/lib/data'

export default async function Page() {
  const posts = await getPosts()

  return <Posts posts={posts} />
}

async function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

### Functions

You can cache the return value of an **asynchronous** function, including data requests, by adding the `'use cache'` directive inside the function body:

```ts filename="app/lib/data.ts" switcher
export async function getPosts(slug: string) {
  'use cache'
  const data = await fetch(`https://api.vercel.app/posts/${slug}`)
  return data.json()
}
```

```js filename="app/lib/data.js" switcher
export async function getPosts(slug) {
  'use cache'
  const data = await fetch(`https://api.vercel.app/posts/${slug}`)
  return data.json()
}
```

You can then call the function throughout your application code and the same cache entry will be reused, as long as the arguments to the function (e.g. `slug`) are the same. If the arguments are different, a new cache key will be created for the new arguments.

Alternatively, you can also cache all functions within a file by adding the `'use cache'` directive at the top of the file. Each function will be cached separately.

```ts filename="app/lib/data.ts" switcher
'use cache'

export async function getPosts() {
  const data = await fetch(`https://api.vercel.app/posts`)
  return data.json()
}

export async function getPostBySlug(slug: string) {
  const data = await fetch(`https://api.vercel.app/posts/${slug}`)
  return data.json()
}
```

```js filename="app/lib/data.js" switcher
'use cache'

export async function getPosts() {
  const data = await fetch(`https://api.vercel.app/posts/`)
  return data.json()
}

export async function getPostBySlug(slug: string) {
  const data = await fetch(`https://api.vercel.app/posts/${slug}`)
  return data.json()
}
```

## Revalidating

Revalidation allows you to update cached content without having to rebuild your entire application. It's useful for content that _sometimes_ changes, but would benefit from being cached to improve your application's performance.

In Next.js, there are two types of revalidation:

- [Time-based](#time-based-revalidation): Based on a time interval (e.g. every hour).
- [On-demand](#on-demand-revalidation): Triggered by a specific event (e.g. a CMS webhook).

## Time-based Revalidation

You can use the [`cacheLife` function](/docs/app/api-reference/functions/cacheLife) to define a time interval for how long a cached value should remain stale before it's revalidated.

`cacheLife` comes with [default cache profiles](/docs/app/api-reference/functions/cacheLife#default-cache-profiles) such as `'hour'`, `'day'`, and `'week'`. These profiles can be [customized](/docs/app/api-reference/functions/cacheLife#custom-cache-profiles), if needed.

To use `cacheLife`, import it from `next/cache` and nest it within the **scope** of the `'use cache'` directive and the function. For example, to revalidate the blog page after one hour:

```tsx filename="app/blog/page.tsx" highlight={3,6} switcher
'use cache'

import { cacheLife } from 'next/cache'

export default async function Page() {
  cacheLife('hour')
  return <Posts posts={posts} />
}
```

```jsx filename="app/blog/page.js" highlight={3,6} switcher
'use cache'

import { cacheLife } from 'next/cache'

export default async function Page() {
  cacheLife('hour')
  return <Posts posts={posts} />
}
```

## On-demand Revalidation

You can use the [`cacheTag` function](/docs/app/api-reference/functions/cacheTag) to define a tag for a cache entry. The entry can then be revalidated using the [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) function in another part of your application, such as a [Server Action](https://react.dev/reference/rsc/server-functions) or [Route Handler](/docs/app/building-your-application/routing/route-handlers).

For example, to update the list of blog posts once a new post is created, add the `cacheTag` function to the component that renders the list of posts:

```tsx filename="app/ui/posts.tsx" switcher
'use cache'

import { cacheTag } from 'next/cache'

export function Posts({ posts }) {
  cacheTag('blog-posts')
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

```jsx filename="app/ui/posts.js" switcher
'use cache'

import { cacheTag } from 'next/cache'

export function Posts({ posts }) {
  cacheTag('blog-posts')
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

Then, in the Server Action to create a new post, call `revalidateTag` using the same tag to purge the cache entry:

```tsx filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  // Mutate data
  // ...

  // Purge cache
  revalidateTag('blog-posts')
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function createPost() {
  // Mutate data
  // ...

  // Purge cache
  revalidateTag('blog-posts')
}
```

Alternatively, you can call the [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) function to purge the whole `/blog` route (in which case you don't need `cacheTag`):

```tsx filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  // Mutate data
  // ...

  // Purge cache
  revalidatePath('/blog')
}
```

```tsx filename="app/actions.ts" switcher
'use server'

import { revalidatePath } from 'next/cache'

export async function createPost() {
  // Mutate data
  // ...

  // Purge cache
  expirePath('/blog')
}
```
